module {GLuanalysis.AG.ControlFlow}{}{}

imports
{
import GLua.AG.AST
import Data.Graph.Inductive.Graph
import Data.Graph.Inductive.PatriciaTree
import qualified GLua.AG.PrettyPrint as PP
}
include "../../GLua/AG/AST.ag"

{

data NodeThing = NStat Stat | NReturn AReturn | NExpr MExpr | NElseIf ElseIf

instance Show NodeThing where
    show (NStat s) = "NStat (" ++ (PP.renderStat s) ++ ")"
    show (NReturn s) = "NReturn (" ++ (PP.renderAReturn s) ++ ")"
    show (NExpr s) = "NExpr (" ++ (PP.renderMExpr s) ++ ")"
    show (NElseIf (x, y)) = "NElseIf (elseif " ++ (PP.renderMExpr x) ++ " then <block> )"

type ANode = LNode NodeThing
type AEdge = LEdge Bool -- TODO: different label for edges
type AnalysisGraph = Gr NodeThing Bool


nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

getGraph :: AST -> AnalysisGraph
getGraph a = controlflow_Syn_AST (wrap_AST (sem_AST a) (Inh_AST 0 0))

getNodes a = nodes_Syn_AST (wrap_AST (sem_AST a) (Inh_AST 0 0))
getEdges a = edges_Syn_AST (wrap_AST (sem_AST a) (Inh_AST 0 0))
}

attr Block MStat Stat MStatList AReturn ElseIf ElseIfList Else
    chn number :: Int

attr AST Block MStat Stat MStatList ElseIf ElseIfList Else AReturn
    syn controlflow :: {AnalysisGraph}
    syn nodes use {++} {[]} :: {[ANode]}
    syn edges use {++} {[]} :: {[AEdge]}

    chn firstNumber :: Int
    chn lastNumber  :: Int

attr AST Block MStat Stat AReturn FuncName PrefixExp PFExprSuffix MExpr Expr Args Field BinOp UnOp MStatList MExprList FieldList Declaration VarsList ExprSuffixList ElseIf ElseIfList Else AReturn
    syn copy :: self

sem MStatList
    | Cons       lhs.nodes       = @hd.nodes ++ @tl.nodes
                 hd.number       = @lhs.number
                 tl.number       = @hd.number
                 lhs.number      = @tl.number
                 lhs.edges       = @hd.edges ++ if null @tl.nodes then [] else (@hd.lastNumber, @tl.firstNumber, True) : @tl.edges
                 loc.firstNumber = @hd.firstNumber

                 -- Use the last number of the head when last element
                 loc.lastNumber  = if @tl.lastNumber == -1 then @hd.lastNumber else @tl.lastNumber
    | Nil        lhs.controlflow = empty
                 lhs.number      = @lhs.number
                 lhs.nodes       = []
                 loc.firstNumber = @lhs.firstNumber
                 loc.lastNumber  = -1

sem ElseIf
    | Tuple      lhs.controlflow = empty
                 lhs.number      = @x2.number
                 lhs.firstNumber = @lhs.number
                 lhs.lastNumber  = @x2.lastNumber
                 x2.number       = @lhs.number + 1
                 lhs.nodes       = [(@lhs.number, NElseIf @loc.copy)] ++ @x2.nodes
                 lhs.edges       = (@lhs.number, @x2.firstNumber, True) :
                                   @x2.edges -- TODO: condition failed edge. Syntesize that and handle with in if.

sem ElseIfList
    | Cons       lhs.controlflow = empty
    | Nil        lhs.controlflow = empty

sem Else
    | Just       lhs.controlflow = empty
                 lhs.number      = @just.number
                 just.number     = @lhs.number
                 lhs.firstNumber = @lhs.number
                 lhs.lastNumber  = @just.lastNumber
    | Nothing    lhs.controlflow = empty

sem AReturn
    | AReturn    lhs.nodes       = [(@lhs.number, NReturn @loc.copy)]
                 lhs.controlflow = empty
                 lhs.number      = @lhs.number
    | NoReturn   lhs.nodes       = []-- TODO: Return statement
                 lhs.controlflow = empty
                 lhs.number      = @lhs.number - 1

sem AST |
    AST lhs.controlflow = mkGraph @chunk.nodes @chunk.edges
        chunk.number = 1

sem Block | Block lhs.controlflow = @stats.controlflow -- fix return address?
                  loc.nodes       = @stats.nodes ++ @ret.nodes
                  lhs.edges       = @stats.edges
                  lhs.number      = @ret.number + 1
                  ret.number      = @stats.number
                  lhs.firstNumber = @stats.firstNumber
                  lhs.lastNumber  = @stats.lastNumber

sem MStat | MStat lhs.controlflow = @stat.controlflow


sem Stat    | ASemicolon lhs.controlflow = empty
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number

            | Def        lhs.controlflow = empty
                         lhs.number      = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)]

            | LocDef     lhs.controlflow = empty
                         lhs.number      = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)]

            | AFuncCall  lhs.controlflow = empty
                         lhs.number      = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] -- todo: function calls

            | ALabel     lhs.controlflow = empty
                         lhs.number      = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] -- TODO: remove label from nodes and create label environment instead

            | ABreak     lhs.controlflow = empty
                         lhs.number      = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] -- TODO: remove break from nodes and create edges to end of deepest loop

            | AContinue  lhs.controlflow = empty
                         lhs.number      = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] -- TODO: remove continue from nodes and create edges to start of deepest loop

            | AGoto      lhs.controlflow = empty
                         lhs.number      = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] -- TODO: remove label from nodes and create edges from label environment instead

            | ADo        lhs.controlflow = empty
                         lhs.number      = @body.number
                         body.number     = @lhs.number
                         loc.firstNumber = @body.firstNumber
                         loc.lastNumber  = @body.lastNumber
                         lhs.nodes       = @body.nodes
                         lhs.edges       = @body.edges

            | AWhile     lhs.controlflow = empty
                         lhs.number      = @body.number
                         body.number     = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @body.lastNumber
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] ++ @body.nodes
                         lhs.edges       = (@loc.lastNumber, @loc.firstNumber, True) :
                                           (@loc.firstNumber, @body.firstNumber, True) :
                                           @body.edges

            | ARepeat    lhs.controlflow = empty
                         lhs.number      = @body.number
                         body.number     = @lhs.number + 1
                         loc.firstNumber = @body.firstNumber
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = @body.nodes ++ [(@lhs.number, NStat @loc.copy)]
                         lhs.edges       = (@body.lastNumber, @lhs.number, True) :
                                           (@lhs.number, @body.firstNumber, True) :
                                           @body.edges

            | AIf        lhs.controlflow = empty
                         body.number     = @lhs.number + 1
                         elifs.number    = @body.number
                         els.number      = @elifs.number
                         lhs.number      = @els.number
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         loc.nodes       = (@lhs.number, NStat @loc.copy) :
                                           @body.nodes ++
                                           @elifs.nodes ++
                                           @els.nodes
                         lhs.edges       = -- TODO: condition fail edges
                                           -- TODO: edges from the ends of all elses and elseifs to the next statement.
                                                -- idea: make lastNumber a list
                                           (@lhs.number, @body.firstNumber, True) :
                                           @body.edges ++ @elifs.edges ++ @els.edges

            | ANFor      lhs.controlflow = empty
                         body.number     = @lhs.number + 1
                         lhs.number      = @body.number
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] ++ @body.nodes
                         lhs.edges       = (@loc.firstNumber, @body.firstNumber, True) :
                                           (@body.lastNumber, @loc.firstNumber, True) :
                                           @body.edges -- TODO: annotate fail edge (now created by sequence) with False or something?

            | AGFor      lhs.controlflow = empty
                         body.number     = @lhs.number + 1
                         lhs.number      = @body.number
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] ++ @body.nodes
                         lhs.edges       = (@loc.firstNumber, @body.firstNumber, True) :
                                           (@body.lastNumber, @loc.firstNumber, True) :
                                           @body.edges -- TODO: annotate fail edge (now created by sequence) with False or something?
            | AFunc      lhs.controlflow = empty

                         lhs.number = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] ++ @body.nodes
            | ALocFunc   lhs.controlflow = empty

                         lhs.number = @lhs.number + 1
                         loc.firstNumber = @lhs.number
                         loc.lastNumber  = @lhs.number
                         lhs.nodes       = [(@lhs.number, NStat @loc.copy)] ++ @body.nodes
